[{"title":"Springboot mybatis中page对象与JSON对象、List对象的相互转换源码","path":"/posts/972.html","content":"前言为什么提出这个转换，是因为我有这样的一个需求，我从数据库使用mybatis查询出一个page对象或者List对象，我想转为JSON数据存到Redis中，然后下次获取的时候，我可以直接读取JSON对象，再转为page或list对象返回给前端。实现反序列化 源码分享下面的代码集成了两者的转换，直接使用即可 工具类代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141package com.bws.firevosapi.utils;import com.baomidou.mybatisplus.core.metadata.IPage;import com.baomidou.mybatisplus.extension.plugins.pagination.Page;import com.bws.firevosapi.config.redis.RedisService;import com.fasterxml.jackson.core.type.TypeReference;import com.fasterxml.jackson.databind.ObjectMapper;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import javax.annotation.Resource;import java.io.IOException;import java.util.List;public class RedisUtils &#123; @Resource private static RedisService redisService; private static final ObjectMapper objectMapper = new ObjectMapper(); private static final Logger logger = LoggerFactory.getLogger(RedisUtils.class); /** * 直接从Redis转为page返回 * @param redisKey * @param clazz * @return * @param &lt;T&gt; */ public static &lt;T&gt; IPage&lt;T&gt; redisJsonToPage(String redisKey,Class&lt;T&gt; clazz)&#123; try &#123; String json = redisService.get(redisKey); // 反序列化 JSON 字符串 PageData&lt;T&gt; pageData = objectMapper.readValue(json, new TypeReference&lt;PageData&lt;T&gt;&gt;() &#123;&#125;); // 构建 IPage 对象 IPage&lt;T&gt; page = new Page&lt;&gt;(pageData.getCurrent(), pageData.getSize(), pageData.getTotal()); page.setRecords(pageData.getRecords()); return page; &#125; catch (IOException e) &#123; logger.error(&quot;JSON 反序列化失败&quot;, e); throw new RuntimeException(&quot;JSON 反序列化失败&quot;, e); &#125; &#125; // 将 JSON 字符串转换为 IPage 对象 public static &lt;T&gt; IPage&lt;T&gt; convertJsonToPage(String jsonString, Class&lt;T&gt; clazz) &#123; try &#123; // 反序列化 JSON 字符串 PageData&lt;T&gt; pageData = objectMapper.readValue(jsonString, new TypeReference&lt;PageData&lt;T&gt;&gt;() &#123;&#125;); // 构建 IPage 对象 IPage&lt;T&gt; page = new Page&lt;&gt;(pageData.getCurrent(), pageData.getSize(), pageData.getTotal()); page.setRecords(pageData.getRecords()); return page; &#125; catch (IOException e) &#123; logger.error(&quot;JSON 反序列化失败&quot;, e); throw new RuntimeException(&quot;JSON 反序列化失败&quot;, e); &#125; &#125; // 将 IPage 对象转换为 JSON 字符串 public static &lt;T&gt; String convertPageToJson(IPage&lt;T&gt; page) &#123; try &#123; String jsonString = objectMapper.writeValueAsString(page); return jsonString; &#125; catch (IOException e) &#123; logger.error(&quot;JSON 序列化失败&quot;, e); throw new RuntimeException(&quot;JSON 序列化失败&quot;, e); &#125; &#125; // 将 List&lt;T&gt; 转换为 JSON 字符串 public static &lt;T&gt; String convertListToJson(List&lt;T&gt; list) &#123; try &#123; return objectMapper.writeValueAsString(list); &#125; catch (IOException e) &#123; throw new RuntimeException(&quot;List 转 JSON 失败&quot;, e); &#125; &#125; // 将 JSON 字符串转换为 List&lt;T&gt; public static &lt;T&gt; List&lt;T&gt; convertJsonToList(String jsonString, Class&lt;T&gt; clazz) &#123; try &#123; return objectMapper.readValue(jsonString, objectMapper.getTypeFactory().constructCollectionType(List.class, clazz)); &#125; catch (IOException e) &#123; throw new RuntimeException(&quot;JSON 转 List 失败&quot;, e); &#125; &#125; // 定义泛型 PageData 类，用于解析 JSON private static class PageData&lt;T&gt; &#123; private List&lt;T&gt; records; private long total; private long size; private long current; private long pages; // Getter 和 Setter 方法 public List&lt;T&gt; getRecords() &#123; return records; &#125; public void setRecords(List&lt;T&gt; records) &#123; this.records = records; &#125; public long getTotal() &#123; return total; &#125; public void setTotal(long total) &#123; this.total = total; &#125; public long getSize() &#123; return size; &#125; public void setSize(long size) &#123; this.size = size; &#125; public long getCurrent() &#123; return current; &#125; public void setCurrent(long current) &#123; this.current = current; &#125; public long getPages() &#123; return pages; &#125; public void setPages(long pages) &#123; this.pages = pages; &#125; &#125;&#125; 使用说明参考下面的这段片段 1234567891011121314151617181920212223242526@Overridepublic IPage&lt;Param&gt; findParamListByUserId(IPage&lt;Param&gt; page, ParamQueryVo paramQueryVo) &#123; // 创建条件构造器 QueryWrapper&lt;Param&gt; queryWrapper = new QueryWrapper&lt;&gt;(); // 条件查询 queryWrapper.like(!ObjectUtils.isEmpty(paramQueryVo.getParamName()), &quot;param_name&quot;, paramQueryVo.getParamName()); // 排序 queryWrapper.orderByAsc(&quot;param_id&quot;); IPage&lt;Param&gt; iPage = new Page&lt;&gt;(); String roleJson = redisService.get(SystemConstants.PARAM_TOKEN_KEY); if (ObjectUtil.isNull(roleJson)) &#123; // 根据用户id查询用户信息 User user = userMapper.selectById(paramQueryVo.getUserId()); if (user != null &amp;&amp; !ObjectUtils.isEmpty(user.getIsAdmin()) &amp;&amp; user.getIsAdmin() != 1) &#123; // 非管理员只能查询自己创建的角色 queryWrapper.eq(&quot;create_user&quot;, paramQueryVo.getUserId()); &#125; iPage = baseMapper.selectPage(page, queryWrapper); redisService.set(SystemConstants.PARAM_TOKEN_KEY, RedisUtils.convertPageToJson(iPage), redisService.getExpire()); &#125; else &#123; iPage = RedisUtils.convertJsonToPage(roleJson, Param.class); &#125; return iPage;&#125; redisService以及其他方法需要自己实现，只需要关注 RedisUtils.即可","tags":["springboot","mybatis","redis","List对象","Page对象","反序列化"],"categories":["技术开发","springboot"]},{"title":"SpringBoot Controller接收参数的几种方式","path":"/posts/5ba3.html","content":"SpringBoot Controller接收参数的几种方式@PathVariable接收参数 请求方式：localhost:7001&#x2F;param&#x2F;123 代码示例： 1234@GetMapping(&quot;&#123;id&#125;&quot;)public String getPathVariable(@PathVariable String id)&#123; return &quot;id=&quot;+id;&#125; @RequestParam接收参数使用这个注解需要注意两个点，一是加了这个参数后则请求中必须传递这个参数，二是@RequestParam这个注解可以指定名字，请求参数必须和指定的这个名字相同，如果不指定，则默认为具体参数名。 请求方式：localhost:7001&#x2F;param&#x2F;getParam?myId&#x3D;18 代码示例： 1234@GetMapping(&quot;getParam&quot;)public String getRequestParam(@RequestParam(&quot;myId&quot;) String id)&#123; return &quot;id=&quot;+id;&#125; 无注解传参这种方式和2对比，最大的区别就是这个参数不是必传的，请求路径上可以不传递。 请求方式：localhost:7001&#x2F;param&#x2F;getString?id&#x3D;18 代码示例： 1234@GetMapping(&quot;getString&quot;)public String getString(String id)&#123; return &quot;id=&quot;+id;&#125; HttpServletRequest接收参数 请求方式：localhost:7001&#x2F;param&#x2F;getRequest?id&#x3D;18 代码示例： 12345@GetMapping(&quot;getRequest&quot;)public String getRequest(HttpServletRequest request)&#123; String id = request.getParameter(&quot;id&quot;); return &quot;id=&quot;+id;&#125; @RequestBody接收请求体参数这种方式一般用来传递实体对象，加了这个注解后，参数也是必传的。 请求方式：{“id”:18} 代码示例: 1234@PostMapping(&quot;getBody&quot;)public String getBody(@RequestBody String id)&#123; return &quot;id=&quot;+id;&#125; @RequestHeader接收请求头参数代码示例： 1234@PostMapping(&quot;getHeader&quot;)public String getHeader(@RequestHeader String id)&#123; return &quot;id=&quot;+id;&#125;","tags":["springboot","REST API","srpingboot参数"],"categories":["技术开发","springboot"]},{"title":"springboot集成mybatis-plus实现CRUD","path":"/posts/74da.html","content":"官方地址：https://baomidou.com/ pom.xml12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 增加依赖 Config配置类123456789package com.bws.CFP.Config;import org.mybatis.spring.annotation.MapperScan;import org.springframework.context.annotation.Configuration;@Configuration@MapperScan(&quot;com.bws.CFP.mapper&quot;)public class MyBatisConfig &#123;&#125; 目前不需要配置，后续研究可以有什么增强配置 新建Mapper xml配置src&#x2F;main&#x2F;resources 路径下增加：UserMapper.xml 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.bws.CFP.Mapper.UserMapper&quot;&gt; &lt;select id=&quot;getByName&quot; resultType=&quot;com.bws.CFP.Entity.User&quot;&gt; SELECT * FROM `user` WHERE `name` = #&#123;name&#125; &lt;/select&gt;&lt;/mapper&gt; 启动类修改增加Mapper扫描 123456789@SpringBootApplication@MapperScan(&quot;com.bws.CFP.mapper&quot;) // mapper 接口所在的包public class CfpApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(CfpApplication.class, args); &#125;&#125; application配置12345678910111213141516171819spring: # 基本的数据源配置 datasource: type: com.zaxxer.hikari.HikariDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/cfp?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=GMT%2b8&amp;allowMultiQueries=true username: root password: 111111# MyBatis Plus 的配置#开启日志mybatis-plus: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl # mybatis 配置文件的路径 # config-location: &quot;classpath:mybatis/mybatis.config&quot; # mapper 映射文件的路径，可以有多个 mapper-locations: - &quot;classpath*:mappers/**/*.xml&quot; 实现查询数据准备12345678910111213141516171819202122CREATE DATABASE `CFP` CHARACTER SET &#x27;utf8mb4&#x27; COLLATE &#x27;utf8mb4_bin&#x27;;-- test 数据DROP TABLE IF EXISTS user;CREATE TABLE user(\tid BIGINT(20) NOT NULL COMMENT &#x27;主键ID&#x27;,\tname VARCHAR(30) NULL DEFAULT NULL COMMENT &#x27;姓名&#x27;,\tage INT(11) NULL DEFAULT NULL COMMENT &#x27;年龄&#x27;,\temail VARCHAR(50) NULL DEFAULT NULL COMMENT &#x27;邮箱&#x27;,\tPRIMARY KEY (id));INSERT INTO user (id, name, age, email) VALUES(1, &#x27;Jone&#x27;, 18, &#x27;test1@baomidou.com&#x27;),(2, &#x27;Jack&#x27;, 20, &#x27;test2@baomidou.com&#x27;),(3, &#x27;Tom&#x27;, 28, &#x27;test3@baomidou.com&#x27;),(4, &#x27;Sandy&#x27;, 21, &#x27;test4@baomidou.com&#x27;),(5, &#x27;Billie&#x27;, 24, &#x27;test5@baomidou.com&#x27;);-- test 数据 Entity实体类新建User类 123456789101112131415161718192021222324package com.bws.CFP.Entity;import com.baomidou.mybatisplus.annotation.IdType;import com.baomidou.mybatisplus.annotation.TableField;import com.baomidou.mybatisplus.annotation.TableId;import com.baomidou.mybatisplus.annotation.TableName;import lombok.Data;@TableName(&quot;user&quot;)@Data //lombok中的注解，自动生成getter&amp;setter方法public class User &#123; @TableId(type = IdType.AUTO) private Long id; @TableField private String name; @TableField private Integer age; @TableField private String email;&#125; 新建Mapper接口1234567891011121314package com.bws.CFP.Mapper;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import org.apache.ibatis.annotations.Mapper;@Mapperpublic interface UserMapper extends BaseMapper&lt;User&gt; &#123; /** * 根据 name 检索一条记录 * @param name * @return */ User getByName(String name);&#125; 新建Servicecom.bws.CFP.Service 1234567package com.bws.CFP.Service;import com.baomidou.mybatisplus.extension.service.IService;public interface IUserService extends IService&lt;User&gt; &#123; User getByName(String name);&#125; com.bws.CFP.Service.Impl 12345678910111213141516171819package com.bws.CFP.Service.Impl;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;// UserServiceImpl 实现类，实现 UserService 接口，并且继承 ServiceImpl 抽象类@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements IUserService &#123; @Autowired UserMapper userMapper; @Override public User getByName(String name) &#123; User user = userMapper.getByName(name); return user; &#125;&#125; 新建Controller12345678910111213141516171819package com.bws.CFP.Controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123; @Autowired IUserService userService; @RequestMapping(&quot;/getUser&quot;) public User getUser(String userName) &#123; User user = userService.getByName(&quot;刘备&quot;); return user; &#125;&#125; 发起测试","categories":["技术开发","springboot","数据库"]},{"title":"springboot集成日志打印框架","path":"/posts/c12f.html","content":"日志框架的选择常见的日志框架参考文章：https://segmentfault.com/a/1190000022832278 日志级别在日志系统中，通常会定义不同的日志级别，用于标识日志的重要性或严重性。以下是常见的日志级别，按照从低到高的顺序排列： ALL：所有日志。 DEBUG：用于调试信息，通常用于开发和调试阶段。 INFO：提供程序运行时的重要信息，用于指示应用程序正常运行。 WARN：表示潜在的问题，不会导致应用程序失败，但可能需要关注。 ERROR：表示错误事件，可能导致应用程序出现问题。 OFF：关闭日志。 Log4j2 集成（异步日志）注意点: (1). springboot默认是logback日志框架, 需要先排除spring-boot-starter-logging包, 否则会引起jar包冲突 (2). 如果要配置log4j2异步日志, 需要添加disruptor依赖 pom.xml 配置1234567891011121314151617181920212223242526272829303132333435&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;!--springboot默认是logback日志框架, 需先排除此依赖, 否则会和log4j2产生jar包冲突--&gt; &lt;!--但是这种排除方式不一定有效，因为可能别的依赖包里也集成了默认的日志，这样的话项目启动依旧会报冲突--&gt; &lt;!--&lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;--&gt; &lt;/dependency&gt; &lt;!-- 全局排除spring-boot-starter-logging相关所有依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;*&lt;/groupId&gt; &lt;artifactId&gt;*&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!-- 引入log4j2依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 使用log4j2的Async配置需要引入disruptor包 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.lmax&lt;/groupId&gt; &lt;artifactId&gt;disruptor&lt;/artifactId&gt; &lt;/dependency&gt; application.yaml 配置12logging: config: classpath:log4j2.xml log4j2.xml同步配置:以下为同步日志配置: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!--Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，你会看到log4j2内部各种详细输出--&gt;&lt;!--monitorInterval：Log4j能够自动检测修改配置文件和重新配置本身(无需重启,热更新)，设置间隔秒数--&gt;&lt;Configuration status=&quot;WARN&quot; monitorInterval=&quot;1800&quot;&gt; &lt;!--日志级别以及优先级排序: ALL &lt; TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL &lt; OFF --&gt; &lt;!--变量配置--&gt; &lt;Properties&gt; &lt;!--应用名称--&gt; &lt;property name=&quot;APP_NAME&quot;&gt;sky-hello&lt;/property&gt; &lt;!--日志存放路径--&gt; &lt;property name=&quot;LOG_PATH&quot;&gt;./logs/$&#123;APP_NAME&#125;&lt;/property&gt; &lt;!--日志备份路径--&gt; &lt;property name=&quot;LOG_BACKUP_PATH&quot;&gt;$&#123;LOG_PATH&#125;/backup&lt;/property&gt; &lt;!--日志输出格式-控制台--&gt; &lt;property name=&quot;PATTERN_CONSOLE&quot;&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; | %blue&#123;%traceId&#125; | %highlight&#123;%-5p&#125; | %magenta&#123;$&#123;sys:PID&#125;&#125; | %yellow&#123;%t&#125; | %cyan&#123;%l&#125; : %msg%n&lt;/property&gt; &lt;!--日志输出格式-文件--&gt; &lt;property name=&quot;PATTERN_FILE&quot;&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; | %traceId | %-5p | $&#123;sys:PID&#125; | %t | %l : %msg%n&lt;/property&gt; &lt;/Properties&gt; &lt;!--定义日志输出目的地，内容和格式等--&gt; &lt;Appenders&gt; &lt;!--控制台--&gt; &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;!--输出日志的格式: 1.不设置默认为: %m%n 2.disableAnsi=&quot;false&quot; noConsoleNoAnsi=&quot;false&quot; 配置开启支持%highlight彩色日志 --&gt; &lt;PatternLayout pattern=&quot;$&#123;PATTERN_CONSOLE&#125;&quot; disableAnsi=&quot;false&quot; noConsoleNoAnsi=&quot;false&quot;/&gt; &lt;!--只输出level及其以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt; &lt;ThresholdFilter level=&quot;DEBUG&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;/Console&gt; &lt;!--可归档文件 1. fileName: 日志存储路径 2. filePattern: 历史日志封存路径。其中%d&#123;yyyy-MM-dd&#125;表示了日志的时间单位是天,log4j2自动识别zip等后缀，表示历史日志需要压缩 --&gt; &lt;RollingFile name=&quot;RollingFile&quot; fileName=&quot;$&#123;LOG_PATH&#125;/$&#123;APP_NAME&#125;.log&quot; filePattern=&quot;$&#123;LOG_BACKUP_PATH&#125;/$$&#123;date:yyyy-MM&#125;/$&#123;APP_NAME&#125;-%d&#123;yyyy-MM-dd&#125;_%i.log.zip&quot;&gt; &lt;!--输出日志的格式, 不设置默认为:%m%n--&gt; &lt;PatternLayout pattern=&quot;$&#123;PATTERN_FILE&#125;&quot;/&gt; &lt;!--只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt; &lt;ThresholdFilter level=&quot;DEBUG&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;!--归档设置--&gt; &lt;Policies&gt; &lt;!--按时间间隔归档: 1. interval=时间间隔, 单位由filePattern的%d日期格式指定, 此处配置代表每一天归档一次 2. modulate=&quot;true&quot; 是否对interval取模，决定了下一次触发的时间点 --&gt; &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot; /&gt; &lt;!-- 按照日志文件的大小: size表示当前日志文件的最大size，支持单位：KB/MB/GB--&gt; &lt;SizeBasedTriggeringPolicy size=&quot;50MB&quot;/&gt; &lt;/Policies&gt; &lt;!-- 历史日志配置: 该属性如不设置，则默认为最多同一文件夹下7个文件开始覆盖--&gt; &lt;DefaultRolloverStrategy max=&quot;30&quot;/&gt; &lt;/RollingFile&gt; &lt;!--错误信息单独归档--&gt; &lt;RollingFile name=&quot;RollingFileError&quot; fileName=&quot;$&#123;LOG_PATH&#125;/$&#123;APP_NAME&#125;-error.log&quot; filePattern=&quot;$&#123;LOG_BACKUP_PATH&#125;/$$&#123;date:yyyy-MM&#125;/$&#123;APP_NAME&#125;-error-%d&#123;yyyy-MM-dd&#125;_%i.log.zip&quot;&gt; &lt;PatternLayout pattern=&quot;$&#123;PATTERN_FILE&#125;&quot;/&gt; &lt;ThresholdFilter level=&quot;ERROR&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy/&gt; &lt;SizeBasedTriggeringPolicy size=&quot;50MB&quot;/&gt; &lt;/Policies&gt; &lt;/RollingFile&gt; &lt;/Appenders&gt; &lt;!--Loggers配置--&gt; &lt;Loggers&gt; &lt;!-- 注意点: 1. logger节点用来单独指定日志的形式，比如要为指定包下的class指定不同的日志级别等: (1). name: 用来指定该logger所适用的类或者类所在的包全路径,继承自Root节点. (2). AppenderRef：关联的Appender, 只有定义了logger并引入的appender，appender才会生效 (3). additivity: logEvent的传递性。true LogEvent处理后传递给父Logger打印。false LogEvent处理后不再向上传递给父Logger(解决日志重复输出问题) (4). logger配置的level必须高于或等于Appenders中ThresholdFilter配置的过滤level, 否则会造成信息丢失 2. root配置日志的根节点 --&gt; &lt;!-- 同步日志配置--&gt; &lt;logger name=&quot;com.sky.hello.mapper&quot; level=&quot;debug&quot; additivity=&quot;false&quot;&gt; &lt;AppenderRef ref=&quot;Console&quot;/&gt; &lt;AppenderRef ref=&quot;RollingFile&quot;/&gt; &lt;AppenderRef ref=&quot;RollingFileError&quot;/&gt; &lt;/logger&gt; &lt;root level=&quot;info&quot;&gt; &lt;AppenderRef ref=&quot;Console&quot;/&gt; &lt;AppenderRef ref=&quot;RollingFile&quot;/&gt; &lt;AppenderRef ref=&quot;RollingFileError&quot;/&gt; &lt;/root&gt; &lt;/Loggers&gt;&lt;/Configuration&gt; log4j2异步配置(1). 全局配置异步①. 修改参数: JVM参数方式: 12JVM启动参数（boot.ini）加上“-DLog4jContextSelector=org.apache.logging.log4j.core.async.AsyncLoggerContextSelector” System参数方式 123456789101112@SpringBootApplicationpublic class SkyHelloApplication &#123; public static void main(String[] args) &#123; /** * log4j2异步日志全局配置，减小输出日志对性能的影响 */ System.setProperty(&quot;Log4jContextSelector&quot;, &quot;org.apache.logging.log4j.core.async.AsyncLoggerContextSelector&quot;); SpringApplication.run(SkyHelloApplication.class, args); &#125;&#125; 上述两种修改参数方式, 任选一种即可 ②. 修改log4j2.xml配置中的Loggers节点如下: 增加 includeLocation&#x3D;”true” 属性, 否则日志不会输出%l相关详细信息 12345678910111213&lt;Loggers&gt; &lt;logger name=&quot;com.sky.hello.mapper&quot; level=&quot;debug&quot; additivity=&quot;false&quot; includeLocation=&quot;true&quot;&gt; &lt;AppenderRef ref=&quot;Console&quot;/&gt; &lt;AppenderRef ref=&quot;RollingFile&quot;/&gt; &lt;AppenderRef ref=&quot;RollingFileError&quot;/&gt; &lt;/logger&gt; &lt;root level=&quot;info&quot; includeLocation=&quot;true&quot;&gt; &lt;AppenderRef ref=&quot;Console&quot;/&gt; &lt;AppenderRef ref=&quot;RollingFile&quot;/&gt; &lt;AppenderRef ref=&quot;RollingFileError&quot;/&gt; &lt;/root&gt; &lt;/Loggers&gt; (2). 指定局部Logger节点配置异步log4j2.xml配置文件中使用AsyncRoot&#x2F;AsyncLogger替代Root&#x2F;Logger 12345678910111213141516&lt;Loggers&gt; &lt;!-- 异步日志配置: includeLocation: true表示输出logger相关行号信息 --&gt; &lt;AsyncLogger name=&quot;com.sky.hello.mapper&quot; level=&quot;debug&quot; additivity=&quot;false&quot; includeLocation=&quot;true&quot;&gt; &lt;AppenderRef ref=&quot;Console&quot;/&gt; &lt;AppenderRef ref=&quot;RollingFile&quot;/&gt; &lt;AppenderRef ref=&quot;RollingFileError&quot;/&gt; &lt;/AsyncLogger&gt; &lt;AsyncRoot level=&quot;info&quot; includeLocation=&quot;true&quot;&gt; &lt;AppenderRef ref=&quot;Console&quot;/&gt; &lt;AppenderRef ref=&quot;RollingFile&quot; /&gt; &lt;AppenderRef ref=&quot;RollingFileError&quot;/&gt; &lt;/AsyncRoot&gt; &lt;/Loggers&gt; 上述2种方式任选其一即可，不要同时采用 如果异步日志配置成功, 程序启动后, 可在idea中查看到log4j2生成的异步日志输出线程","tags":["springboot","日志框架","Log4j2"],"categories":["技术开发","springboot"]},{"title":"springboot 集成 Knife4j API接口文档","path":"/posts/28b0.html","content":"官方网址：https://doc.xiaominfo.com/docs/quick-start Knife4j是一个集Swagger2 和 OpenAPI3为一体的增强解决方案 参考：https://blog.csdn.net/xhmico/article/details/131701790 注解说明：https://blog.csdn.net/sxlesq/article/details/131831719 基础配置pom.xml增加依赖，本依赖适用于springboot2.X 12345&lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-openapi3-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;4.3.0&lt;/version&gt;&lt;/dependency&gt; 增加依赖，本依赖适用于springboot3.X 12345&lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-openapi3-jakarta-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;4.4.0&lt;/version&gt;&lt;/dependency&gt; application.yaml增加相关配置 123456789101112131415161718# spring-doc-openapi项目配置spring-doc: swagger-ui: path: /swagger-ui.html tags-sorter: alpha operations-sorter: alpha api-docs: path: /v3/api-docs group-configs: - group: &#x27;默认分组&#x27; paths-to-match: &#x27;/**&#x27; packages-to-scan: com.bws.CFP# knife4j的增强配置，不需要增强可以不配knife4j: enable: true setting: enable-footer: false packages-to-scan: com.bws.CFP 修改为自己项目的包地址 配置类新建 Knife4jConfig 配置类，指定配置项 123456789101112131415161718192021package com.bws.CFP.config;import io.swagger.v3.oas.models.OpenAPI;import io.swagger.v3.oas.models.info.Contact;import io.swagger.v3.oas.models.info.Info;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class Knife4jConfig &#123; @Bean public OpenAPI customOpenAPI() &#123; return new OpenAPI() .info(new Info() .title(&quot;Knife4j示例项目 - 接口文档&quot;) .description(&quot;项目简介，支持Markdown格式：`这里是代码标签哦`，**这里是强调哦**&quot;) .version(&quot;V1.0&quot;) .contact(new Contact().name(&quot;宋冠巡&quot;)) ); &#125;&#125; 测试Controller12345678910111213141516171819202122232425262728293031323334353637package com.bws.CFP.controller;import io.swagger.v3.oas.annotations.Operation;import io.swagger.v3.oas.annotations.Parameter;import io.swagger.v3.oas.annotations.Parameters;import io.swagger.v3.oas.annotations.enums.ParameterIn;import io.swagger.v3.oas.annotations.tags.Tag;import org.springframework.lang.Nullable;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping(&quot;index&quot;)@Tag(name = &quot;首页&quot;)public class IndexController &#123; @Operation(summary = &quot;向客人问好&quot;) @Parameter(name = &quot;name&quot;, description = &quot;姓名&quot;, in = ParameterIn.QUERY) @GetMapping(&quot;/hello&quot;) public String sayHi(@RequestParam String name) &#123; return &quot;Hi:&quot; + name; &#125; @Operation(summary = &quot;测试参数可以为空&quot;) @Parameters(&#123; @Parameter(name = &quot;name&quot;, description = &quot;姓名&quot;, in = ParameterIn.QUERY) &#125;) @GetMapping(&quot;/nullable&quot;) public String testNullable(@Nullable String name) &#123; return &quot;Hi:&quot; + name; &#125;&#125; 测试访问访问地址：http://localhost:8080/doc.html 高级配置暂未编写","tags":["springboot","API文档","swagger","Knife4j"],"categories":["技术开发","springboot"]},{"title":"增加一个hexo融合指令，一键完成hexo clean-g-s，完成服务重启","path":"/posts/1d5.html","content":"前言我们在使用hexo的时候，如果需要重启服务，完整的指令应该是： 123hexo cleanhexo ghexo s 一套下来之后，就会完成服务的重启，但是连续敲这么多，是比较麻烦的，所以，可以使用下面的方法简短一下指令。 简短指令为了整合指令，我们可以在 package.json中找到 scripts，然后增加下面的命令： 1&quot;test&quot;: &quot;hexo clean &amp;&amp; hexo generate &amp;&amp; hexo server&quot; 完整的应该是： 1234567891011121314151617181920212223242526272829303132&#123; &quot;name&quot;: &quot;hexo-site&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;private&quot;: true, &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;hexo generate&quot;, &quot;clean&quot;: &quot;hexo clean&quot;, &quot;deploy&quot;: &quot;hexo deploy&quot;, &quot;server&quot;: &quot;hexo server&quot;, &quot;test&quot;: &quot;hexo clean &amp;&amp; hexo generate &amp;&amp; hexo server&quot; &#125;, &quot;hexo&quot;: &#123; &quot;version&quot;: &quot;7.3.0&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;hexo&quot;: &quot;^7.3.0&quot;, &quot;hexo-abbrlink&quot;: &quot;^2.2.1&quot;, &quot;hexo-deployer-git&quot;: &quot;^4.0.0&quot;, &quot;hexo-generator-archive&quot;: &quot;^2.0.0&quot;, &quot;hexo-generator-category&quot;: &quot;^2.0.0&quot;, &quot;hexo-generator-feed&quot;: &quot;^3.0.0&quot;, &quot;hexo-generator-index&quot;: &quot;^4.0.0&quot;, &quot;hexo-generator-tag&quot;: &quot;^2.0.0&quot;, &quot;hexo-related-popular-posts&quot;: &quot;^5.0.1&quot;, &quot;hexo-renderer-ejs&quot;: &quot;^2.0.0&quot;, &quot;hexo-renderer-marked&quot;: &quot;^6.3.0&quot;, &quot;hexo-renderer-stylus&quot;: &quot;^3.0.1&quot;, &quot;hexo-server&quot;: &quot;^3.0.0&quot;, &quot;hexo-theme-landscape&quot;: &quot;^1.0.0&quot;, &quot;hexo-theme-stellar&quot;: &quot;^1.29.1&quot; &#125;&#125; 完成后，直接运行： 1npm run test 当然，你也可以定义 test 为其他的内容","tags":["hexo部署","hexo指令"],"categories":["网站建设"]},{"title":"Idea打开eclipse项目时，打开内容为空问题","path":"/posts/4ec5.html","content":"今天IDEA打开一个项目时，idea左侧project模式下，不显示项目工程目录，特记录一下解决方案。 正常的先打开eclipse项目，然后再进行下列操作。 清空缓存首先清空idea的缓存，然后自动重启idea 项目结构然后设置项目结构 然后再模块处导入模块 选择需要导入的项目，然后一直下一步 最后，就可以在左侧看到项目结构了","tags":["Idea使用","项目导入"],"categories":["解决方案"]},{"title":"完全免费的Mac软件下载站分享","path":"/posts/6b0b.html","content":"很多人不知道MacBook除了应用上店内的应用还可以在第三方平台下载免费白嫖(破劫)的软件。 今天给大家分享几个我常用的软件下载网站，几乎99%的应用都可以在下面几个网站找到，大家可以点赞收藏起来。 Appstorrent 网站地址: https://appstorrent.ru/ 如果您正在寻找难以在其他地方找到的Mac软件，appstorrent这个位于俄罗斯的网站可能会满足您的需求。它提供了一个广泛的免费Mac软件资源库，让用户可以轻松搜索和下载所需的应用程序,过程中需要您有个科学的网络工具。 MacApp分享频道 网站地址：https://macapp.org.cn/app/ MacApp分享频道是一个专注于分享Mac资源的频道。一些隐藏的技术大佬们一起为爱发电贡献的频道,基本上满足你平时需要用的所有软件需求,并且这些软件都是免费的！ MacWK 网站地址:https://macwk.cn/ 收录了一些最新全网Mac免费软件 这个网站是通过一个GitHub 开源项目搭建的,如果大家感兴趣的话可以去看看这个GitHub开源项目. 项目地址:https://github.com/Thecosy/IceCMS 马可喵 网站地址:https://www.macat.vip/ 一个免费白嫖Mac的资源网站,免费软件有下载次数限制,每天只能2次免费下载,部分软件需要付费,反正我是没充过钱,次数超了换个账号就行了,主打一个白嫖! 其他我自己平时就用以上这些网站找软件,一般99%的软件都能在上面找到,最后再给大家放一些其他的资源网站,大家请自行测评吧! 马可波罗:https://www.macbl.com/ MacYY：https://www.macyy.cn/ xclient:https://xclient.info/ Digit77：digit77.com awesome-mac：https://github.com/jaywcjlove/awesome-mac/blob/master/README-zh.md 小怪兽MAC分享屋:https://macbv.com/ 史蒂芬周的博客:https://www.sdifen.com/ 总结如果你在一些白嫖资源站上下载需要付费,建议你换个资源站就可以了,我平时就是这么干的,咱们主打一个就是白嫖!","tags":["网站推荐","Mac软件","下载网站"],"categories":["效率工具","效率网站"]},{"path":"/css/style.css","content":"/* 文章内链接 */ li:not([class]) a:not([class]), p:not([class]) a:not([class]), table a:not([class]) { /*color: var(--theme-link);*/ padding-bottom: 3px; /* 增加底部padding */ padding-right: 1px; margin-right: 2px; background: linear-gradient(0, var(--theme-link), var(--theme-link)) no-repeat center bottom / 100% 2px; } /* 运行时间 */ .runtime { font-weight: bold; color: #7F84A7; } /* 美化滚动条 */ ::-webkit-scrollbar { width: 5px; height: 5px; } ::-webkit-scrollbar-track { width: 6px; background: rgba(#101F1C, 0.1); -webkit-border-radius: 2em; -moz-border-radius: 2em; border-radius: 2em; } ::-webkit-scrollbar-thumb { background-color: rgba(144,147,153,.5); background-clip: padding-box; min-height: 28px; -webkit-border-radius: 2em; -moz-border-radius: 2em; border-radius: 2em; transition: background-color .3s; cursor: pointer; } ::-webkit-scrollbar-thumb:hover { background-color: rgba(144,147,153,.3); } /* 选中文本：使用超链接高亮的背景色 */ ::selection { background: var(--theme-link-opa); } /* 默认的浅色模式颜色 */ :root { --tag-bg-color: #F2EEFD; --tag-text-color: #835EEC; } /* 暗黑模式下的颜色 */ @media (prefers-color-scheme: dark) { :root { --tag-bg-color: #282433; --tag-text-color: #A28BF2; } } @font-face{ font-family: 'LXGW WenKai' font-weight: normal font-style: normal }"},{"title":"友链","path":"/friends/index.html","content":"某某某"},{"path":"/js/custom_fun.js","content":"// adjust-code-block-height.js // 限制代码块高度 document.addEventListener(\"DOMContentLoaded\", function() { // 选择所有的.md-text元素 var codeBlocks = document.querySelectorAll('.md-text'); // 遍历每个.md-text元素 codeBlocks.forEach(function(block) { // 检查是否包含.highlight类的子元素，且父元素高度超过500px var highlightBlocks = block.querySelectorAll('.highlight'); highlightBlocks.forEach(function(highlightBlock) { if (highlightBlock.clientHeight > 500) { highlightBlock.style.maxHeight = '300px'; highlightBlock.style.overflow = 'auto'; } }); }); }); // add-external-link-icon.js // 外部链接后面显示图标 document.addEventListener('DOMContentLoaded', function () { const links = document.querySelectorAll('article.md-text.content a, footer.page-footer.footnote a'); links.forEach(function(link) { const parentClasses = ['tag-plugin.users-wrap', 'tag-plugin.sites-wrap', 'tag-plugin.ghcard', 'tag-plugin.link.dis-select', 'tag-plugin.colorful.note', 'social-wrap.dis-select']; let skip = false; parentClasses.forEach(pc => { if (link.closest(`div.${pc}`)) { skip = true; } }); if (!skip) { const href = link.getAttribute('href'); if (href && (href.startsWith('http') || href.startsWith('/'))) { link.innerHTML += ` `; } } }); }); // hexo.extend.filter.register('after_render:html', function (data) { // const posts = [] // hexo.locals.get('posts').map(function (post) { // if (post.random !== false) posts.push(post.path) // }) // data += `var posts=${JSON.stringify(posts)};function toRandomPost(){ window.pjax ? pjax.loadUrl('/'+posts[Math.floor(Math.random()*posts.length)]) : window.open('/'+posts[Math.floor(Math.random()*posts.length)], \"_self\"); };` // return data // })"}]